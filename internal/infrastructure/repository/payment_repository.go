package repository

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"

	"turivo-backend/internal/domain"
	"turivo-backend/internal/infrastructure/db/sqlc"
)

type PaymentRepository struct {
	db      *pgxpool.Pool
	queries *sqlc.Queries
}

func NewPaymentRepository(db *pgxpool.Pool) *PaymentRepository {
	return &PaymentRepository{
		db:      db,
		queries: sqlc.New(db),
	}
}

func (r *PaymentRepository) Create(payment *domain.Payment) error {
	ctx := context.Background()

	payloadJSON, err := json.Marshal(payment.Payload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %w", err)
	}

	var amount pgtype.Numeric
	amount.Valid = true
	_ = amount.Scan(payment.Amount)

	dbPayment, err := r.queries.CreatePayment(ctx, sqlc.CreatePaymentParams{
		ID:             pgtype.UUID{Bytes: payment.ID, Valid: true},
		ReservationID:  payment.ReservationID,
		Gateway:        sqlc.PaymentGateway(payment.Gateway),
		Amount:         amount,
		Currency:       payment.Currency,
		Status:         sqlc.PaymentStatus(payment.Status),
		TransactionRef: payment.TransactionRef,
		Payload:        payloadJSON,
	})
	if err != nil {
		return fmt.Errorf("failed to create payment: %w", err)
	}

	// Update payment with created timestamp
	payment.CreatedAt = dbPayment.CreatedAt.Time

	return nil
}

func (r *PaymentRepository) GetByID(id uuid.UUID) (*domain.Payment, error) {
	ctx := context.Background()

	dbPayment, err := r.queries.GetPaymentByID(ctx, pgtype.UUID{Bytes: id, Valid: true})
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, domain.ErrPaymentNotFound
		}
		return nil, fmt.Errorf("failed to get payment by ID: %w", err)
	}

	return r.mapToDomainPayment(dbPayment), nil
}

func (r *PaymentRepository) GetByReservationID(reservationID string) ([]*domain.Payment, error) {
	ctx := context.Background()

	dbPayments, err := r.queries.GetPaymentsByReservationID(ctx, reservationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get payments by reservation ID: %w", err)
	}

	payments := make([]*domain.Payment, len(dbPayments))
	for i, dbPayment := range dbPayments {
		payments[i] = r.mapToDomainPayment(dbPayment)
	}

	return payments, nil
}

func (r *PaymentRepository) Update(id uuid.UUID, status domain.PaymentStatus, transactionRef *string, payload map[string]interface{}) (*domain.Payment, error) {
	// TODO: Implement when UpdatePayment query is properly generated by SQLC
	return nil, fmt.Errorf("update payment not yet implemented")
}

func (r *PaymentRepository) mapToDomainPayment(dbPayment sqlc.Payment) *domain.Payment {
	var paymentID uuid.UUID
	copy(paymentID[:], dbPayment.ID.Bytes[:])

	payment := &domain.Payment{
		ID:             paymentID,
		ReservationID:  dbPayment.ReservationID,
		Gateway:        domain.PaymentGateway(dbPayment.Gateway),
		Currency:       dbPayment.Currency,
		Status:         domain.PaymentStatus(dbPayment.Status),
		TransactionRef: dbPayment.TransactionRef,
		CreatedAt:      dbPayment.CreatedAt.Time,
	}

	if dbPayment.Amount.Valid {
		// Convert pgtype.Numeric to float64 - simplified approach
		// For now, we'll use a basic conversion
		payment.Amount = 0.0 // TODO: Implement proper numeric conversion
	}

	if len(dbPayment.Payload) > 0 {
		var payload map[string]interface{}
		if err := json.Unmarshal(dbPayment.Payload, &payload); err == nil {
			payment.Payload = payload
		}
	}

	return payment
}
