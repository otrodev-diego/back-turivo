// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: drivers.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDrivers = `-- name: CountDrivers :one
SELECT COUNT(*) FROM drivers d
WHERE ($1 = '' OR d.first_name ILIKE '%' || $1 || '%' OR d.last_name ILIKE '%' || $1 || '%' OR d.id ILIKE '%' || $1 || '%')
  AND ($2 = '' OR d.status = $2::driver_status)
`

type CountDriversParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) CountDrivers(ctx context.Context, arg CountDriversParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDrivers, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDriver = `-- name: CreateDriver :one
INSERT INTO drivers (id, first_name, last_name, rut_or_dni, birth_date, phone, email, photo_url, status, user_id, company_id, vehicle_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, first_name, last_name, rut_or_dni, birth_date, phone, email, photo_url, status, created_at, updated_at, user_id, company_id, vehicle_id
`

type CreateDriverParams struct {
	ID        string       `json:"id"`
	FirstName string       `json:"first_name"`
	LastName  string       `json:"last_name"`
	RutOrDni  string       `json:"rut_or_dni"`
	BirthDate pgtype.Date  `json:"birth_date"`
	Phone     *string      `json:"phone"`
	Email     *string      `json:"email"`
	PhotoUrl  *string      `json:"photo_url"`
	Status    DriverStatus `json:"status"`
	UserID    pgtype.UUID  `json:"user_id"`
	CompanyID pgtype.UUID  `json:"company_id"`
	VehicleID pgtype.UUID  `json:"vehicle_id"`
}

func (q *Queries) CreateDriver(ctx context.Context, arg CreateDriverParams) (Driver, error) {
	row := q.db.QueryRow(ctx, createDriver,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.RutOrDni,
		arg.BirthDate,
		arg.Phone,
		arg.Email,
		arg.PhotoUrl,
		arg.Status,
		arg.UserID,
		arg.CompanyID,
		arg.VehicleID,
	)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.RutOrDni,
		&i.BirthDate,
		&i.Phone,
		&i.Email,
		&i.PhotoUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.CompanyID,
		&i.VehicleID,
	)
	return i, err
}

const createDriverAvailability = `-- name: CreateDriverAvailability :one
INSERT INTO driver_availability (driver_id, regions, days, time_ranges)
VALUES ($1, $2, $3, $4)
ON CONFLICT (driver_id) DO UPDATE SET
    regions = EXCLUDED.regions,
    days = EXCLUDED.days,
    time_ranges = EXCLUDED.time_ranges,
    updated_at = NOW()
RETURNING driver_id, regions, days, time_ranges, updated_at
`

type CreateDriverAvailabilityParams struct {
	DriverID   string `json:"driver_id"`
	Regions    []byte `json:"regions"`
	Days       []byte `json:"days"`
	TimeRanges []byte `json:"time_ranges"`
}

func (q *Queries) CreateDriverAvailability(ctx context.Context, arg CreateDriverAvailabilityParams) (DriverAvailability, error) {
	row := q.db.QueryRow(ctx, createDriverAvailability,
		arg.DriverID,
		arg.Regions,
		arg.Days,
		arg.TimeRanges,
	)
	var i DriverAvailability
	err := row.Scan(
		&i.DriverID,
		&i.Regions,
		&i.Days,
		&i.TimeRanges,
		&i.UpdatedAt,
	)
	return i, err
}

const createDriverBackgroundCheck = `-- name: CreateDriverBackgroundCheck :one
INSERT INTO driver_background_checks (driver_id, status, file_url, checked_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (driver_id) DO UPDATE SET
    status = EXCLUDED.status,
    file_url = EXCLUDED.file_url,
    checked_at = EXCLUDED.checked_at
RETURNING driver_id, status, file_url, checked_at
`

type CreateDriverBackgroundCheckParams struct {
	DriverID  string                `json:"driver_id"`
	Status    BackgroundCheckStatus `json:"status"`
	FileUrl   *string               `json:"file_url"`
	CheckedAt pgtype.Timestamptz    `json:"checked_at"`
}

func (q *Queries) CreateDriverBackgroundCheck(ctx context.Context, arg CreateDriverBackgroundCheckParams) (DriverBackgroundCheck, error) {
	row := q.db.QueryRow(ctx, createDriverBackgroundCheck,
		arg.DriverID,
		arg.Status,
		arg.FileUrl,
		arg.CheckedAt,
	)
	var i DriverBackgroundCheck
	err := row.Scan(
		&i.DriverID,
		&i.Status,
		&i.FileUrl,
		&i.CheckedAt,
	)
	return i, err
}

const createDriverLicense = `-- name: CreateDriverLicense :one
INSERT INTO driver_licenses (driver_id, number, class, issued_at, expires_at, file_url)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (driver_id) DO UPDATE SET
    number = EXCLUDED.number,
    class = EXCLUDED.class,
    issued_at = EXCLUDED.issued_at,
    expires_at = EXCLUDED.expires_at,
    file_url = EXCLUDED.file_url
RETURNING driver_id, number, class, issued_at, expires_at, file_url
`

type CreateDriverLicenseParams struct {
	DriverID  string       `json:"driver_id"`
	Number    string       `json:"number"`
	Class     LicenseClass `json:"class"`
	IssuedAt  pgtype.Date  `json:"issued_at"`
	ExpiresAt pgtype.Date  `json:"expires_at"`
	FileUrl   *string      `json:"file_url"`
}

func (q *Queries) CreateDriverLicense(ctx context.Context, arg CreateDriverLicenseParams) (DriverLicense, error) {
	row := q.db.QueryRow(ctx, createDriverLicense,
		arg.DriverID,
		arg.Number,
		arg.Class,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.FileUrl,
	)
	var i DriverLicense
	err := row.Scan(
		&i.DriverID,
		&i.Number,
		&i.Class,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.FileUrl,
	)
	return i, err
}

const deleteDriver = `-- name: DeleteDriver :exec
DELETE FROM drivers WHERE id = $1
`

func (q *Queries) DeleteDriver(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteDriver, id)
	return err
}

const getDriverByID = `-- name: GetDriverByID :one
SELECT d.id, d.first_name, d.last_name, d.rut_or_dni, d.birth_date, d.phone, d.email, d.photo_url, d.status, d.created_at, d.updated_at, d.user_id, d.company_id, d.vehicle_id, 
       dl.number as license_number, dl.class as license_class, dl.issued_at as license_issued_at, 
       dl.expires_at as license_expires_at, dl.file_url as license_file_url,
       dbc.status as background_status, dbc.file_url as background_file_url, dbc.checked_at as background_checked_at,
       da.regions, da.days, da.time_ranges
FROM drivers d
LEFT JOIN driver_licenses dl ON d.id = dl.driver_id
LEFT JOIN driver_background_checks dbc ON d.id = dbc.driver_id
LEFT JOIN driver_availability da ON d.id = da.driver_id
WHERE d.id = $1
`

type GetDriverByIDRow struct {
	ID                  string                    `json:"id"`
	FirstName           string                    `json:"first_name"`
	LastName            string                    `json:"last_name"`
	RutOrDni            string                    `json:"rut_or_dni"`
	BirthDate           pgtype.Date               `json:"birth_date"`
	Phone               *string                   `json:"phone"`
	Email               *string                   `json:"email"`
	PhotoUrl            *string                   `json:"photo_url"`
	Status              DriverStatus              `json:"status"`
	CreatedAt           pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz        `json:"updated_at"`
	UserID              pgtype.UUID               `json:"user_id"`
	CompanyID           pgtype.UUID               `json:"company_id"`
	VehicleID           pgtype.UUID               `json:"vehicle_id"`
	LicenseNumber       *string                   `json:"license_number"`
	LicenseClass        NullLicenseClass          `json:"license_class"`
	LicenseIssuedAt     pgtype.Date               `json:"license_issued_at"`
	LicenseExpiresAt    pgtype.Date               `json:"license_expires_at"`
	LicenseFileUrl      *string                   `json:"license_file_url"`
	BackgroundStatus    NullBackgroundCheckStatus `json:"background_status"`
	BackgroundFileUrl   *string                   `json:"background_file_url"`
	BackgroundCheckedAt pgtype.Timestamptz        `json:"background_checked_at"`
	Regions             []byte                    `json:"regions"`
	Days                []byte                    `json:"days"`
	TimeRanges          []byte                    `json:"time_ranges"`
}

func (q *Queries) GetDriverByID(ctx context.Context, id string) (GetDriverByIDRow, error) {
	row := q.db.QueryRow(ctx, getDriverByID, id)
	var i GetDriverByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.RutOrDni,
		&i.BirthDate,
		&i.Phone,
		&i.Email,
		&i.PhotoUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.CompanyID,
		&i.VehicleID,
		&i.LicenseNumber,
		&i.LicenseClass,
		&i.LicenseIssuedAt,
		&i.LicenseExpiresAt,
		&i.LicenseFileUrl,
		&i.BackgroundStatus,
		&i.BackgroundFileUrl,
		&i.BackgroundCheckedAt,
		&i.Regions,
		&i.Days,
		&i.TimeRanges,
	)
	return i, err
}

const listDrivers = `-- name: ListDrivers :many
SELECT d.id, d.first_name, d.last_name, d.rut_or_dni, d.birth_date, d.phone, d.email, d.photo_url, d.status, d.created_at, d.updated_at, d.user_id, d.company_id, d.vehicle_id, 
       dl.number as license_number, dl.class as license_class,
       dbc.status as background_status
FROM drivers d
LEFT JOIN driver_licenses dl ON d.id = dl.driver_id
LEFT JOIN driver_background_checks dbc ON d.id = dbc.driver_id
WHERE ($1 = '' OR d.first_name ILIKE '%' || $1 || '%' OR d.last_name ILIKE '%' || $1 || '%' OR d.id ILIKE '%' || $1 || '%')
  AND ($2 = '' OR d.status = $2::driver_status)
ORDER BY 
  CASE WHEN $3 = 'name' THEN d.first_name || ' ' || d.last_name END,
  CASE WHEN $3 = 'id' THEN d.id END,
  CASE WHEN $3 = 'created_at' THEN d.created_at END DESC
LIMIT $4 OFFSET $5
`

type ListDriversParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListDriversRow struct {
	ID               string                    `json:"id"`
	FirstName        string                    `json:"first_name"`
	LastName         string                    `json:"last_name"`
	RutOrDni         string                    `json:"rut_or_dni"`
	BirthDate        pgtype.Date               `json:"birth_date"`
	Phone            *string                   `json:"phone"`
	Email            *string                   `json:"email"`
	PhotoUrl         *string                   `json:"photo_url"`
	Status           DriverStatus              `json:"status"`
	CreatedAt        pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz        `json:"updated_at"`
	UserID           pgtype.UUID               `json:"user_id"`
	CompanyID        pgtype.UUID               `json:"company_id"`
	VehicleID        pgtype.UUID               `json:"vehicle_id"`
	LicenseNumber    *string                   `json:"license_number"`
	LicenseClass     NullLicenseClass          `json:"license_class"`
	BackgroundStatus NullBackgroundCheckStatus `json:"background_status"`
}

func (q *Queries) ListDrivers(ctx context.Context, arg ListDriversParams) ([]ListDriversRow, error) {
	rows, err := q.db.Query(ctx, listDrivers,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDriversRow{}
	for rows.Next() {
		var i ListDriversRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.RutOrDni,
			&i.BirthDate,
			&i.Phone,
			&i.Email,
			&i.PhotoUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.CompanyID,
			&i.VehicleID,
			&i.LicenseNumber,
			&i.LicenseClass,
			&i.BackgroundStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDriver = `-- name: UpdateDriver :one
UPDATE drivers
SET first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    rut_or_dni = COALESCE($4, rut_or_dni),
    birth_date = COALESCE($5, birth_date),
    phone = COALESCE($6, phone),
    email = COALESCE($7, email),
    photo_url = COALESCE($8, photo_url),
    status = COALESCE($9, status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, first_name, last_name, rut_or_dni, birth_date, phone, email, photo_url, status, created_at, updated_at, user_id, company_id, vehicle_id
`

type UpdateDriverParams struct {
	ID        string       `json:"id"`
	FirstName string       `json:"first_name"`
	LastName  string       `json:"last_name"`
	RutOrDni  string       `json:"rut_or_dni"`
	BirthDate pgtype.Date  `json:"birth_date"`
	Phone     *string      `json:"phone"`
	Email     *string      `json:"email"`
	PhotoUrl  *string      `json:"photo_url"`
	Status    DriverStatus `json:"status"`
}

func (q *Queries) UpdateDriver(ctx context.Context, arg UpdateDriverParams) (Driver, error) {
	row := q.db.QueryRow(ctx, updateDriver,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.RutOrDni,
		arg.BirthDate,
		arg.Phone,
		arg.Email,
		arg.PhotoUrl,
		arg.Status,
	)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.RutOrDni,
		&i.BirthDate,
		&i.Phone,
		&i.Email,
		&i.PhotoUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.CompanyID,
		&i.VehicleID,
	)
	return i, err
}
