// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vehicles.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignVehicleToDriver = `-- name: AssignVehicleToDriver :one
UPDATE vehicles
SET 
    driver_id = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, driver_id, type, brand, model, year, plate, vin, color, insurance_policy, insurance_expires_at, inspection_expires_at, created_at, updated_at, status, capacity
`

type AssignVehicleToDriverParams struct {
	ID       pgtype.UUID `json:"id"`
	DriverID *string     `json:"driver_id"`
}

func (q *Queries) AssignVehicleToDriver(ctx context.Context, arg AssignVehicleToDriverParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, assignVehicleToDriver, arg.ID, arg.DriverID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Type,
		&i.Brand,
		&i.Model,
		&i.Year,
		&i.Plate,
		&i.Vin,
		&i.Color,
		&i.InsurancePolicy,
		&i.InsuranceExpiresAt,
		&i.InspectionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Capacity,
	)
	return i, err
}

const countVehicles = `-- name: CountVehicles :one
SELECT COUNT(*) FROM vehicles
WHERE 
    ($1::text IS NULL OR 
        brand ILIKE '%' || $1 || '%' OR 
        model ILIKE '%' || $1 || '%' OR 
        plate ILIKE '%' || $1 || '%')
    AND ($2::vehicle_type IS NULL OR type = $2)
    AND ($3::vehicle_status IS NULL OR status = $3)
    AND ($4::text IS NULL OR driver_id = $4)
`

type CountVehiclesParams struct {
	Column1 string        `json:"column_1"`
	Column2 VehicleType   `json:"column_2"`
	Column3 VehicleStatus `json:"column_3"`
	Column4 string        `json:"column_4"`
}

func (q *Queries) CountVehicles(ctx context.Context, arg CountVehiclesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVehicles,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO vehicles (
    driver_id,
    type,
    brand,
    model,
    year,
    plate,
    vin,
    color,
    capacity,
    insurance_policy,
    insurance_expires_at,
    inspection_expires_at,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, driver_id, type, brand, model, year, plate, vin, color, insurance_policy, insurance_expires_at, inspection_expires_at, created_at, updated_at, status, capacity
`

type CreateVehicleParams struct {
	DriverID            *string       `json:"driver_id"`
	Type                VehicleType   `json:"type"`
	Brand               string        `json:"brand"`
	Model               string        `json:"model"`
	Year                *int32        `json:"year"`
	Plate               *string       `json:"plate"`
	Vin                 *string       `json:"vin"`
	Color               *string       `json:"color"`
	Capacity            *int32        `json:"capacity"`
	InsurancePolicy     *string       `json:"insurance_policy"`
	InsuranceExpiresAt  pgtype.Date   `json:"insurance_expires_at"`
	InspectionExpiresAt pgtype.Date   `json:"inspection_expires_at"`
	Status              VehicleStatus `json:"status"`
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.DriverID,
		arg.Type,
		arg.Brand,
		arg.Model,
		arg.Year,
		arg.Plate,
		arg.Vin,
		arg.Color,
		arg.Capacity,
		arg.InsurancePolicy,
		arg.InsuranceExpiresAt,
		arg.InspectionExpiresAt,
		arg.Status,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Type,
		&i.Brand,
		&i.Model,
		&i.Year,
		&i.Plate,
		&i.Vin,
		&i.Color,
		&i.InsurancePolicy,
		&i.InsuranceExpiresAt,
		&i.InspectionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Capacity,
	)
	return i, err
}

const createVehiclePhoto = `-- name: CreateVehiclePhoto :one
INSERT INTO vehicle_photos (
    vehicle_id,
    url
) VALUES (
    $1, $2
) RETURNING id, vehicle_id, url, created_at
`

type CreateVehiclePhotoParams struct {
	VehicleID pgtype.UUID `json:"vehicle_id"`
	Url       string      `json:"url"`
}

func (q *Queries) CreateVehiclePhoto(ctx context.Context, arg CreateVehiclePhotoParams) (VehiclePhoto, error) {
	row := q.db.QueryRow(ctx, createVehiclePhoto, arg.VehicleID, arg.Url)
	var i VehiclePhoto
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.Url,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVehicle = `-- name: DeleteVehicle :exec
DELETE FROM vehicles
WHERE id = $1
`

func (q *Queries) DeleteVehicle(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVehicle, id)
	return err
}

const deleteVehiclePhoto = `-- name: DeleteVehiclePhoto :exec
DELETE FROM vehicle_photos
WHERE id = $1
`

func (q *Queries) DeleteVehiclePhoto(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVehiclePhoto, id)
	return err
}

const getVehicleByDriverID = `-- name: GetVehicleByDriverID :one
SELECT id, driver_id, type, brand, model, year, plate, vin, color, insurance_policy, insurance_expires_at, inspection_expires_at, created_at, updated_at, status, capacity FROM vehicles
WHERE driver_id = $1
LIMIT 1
`

func (q *Queries) GetVehicleByDriverID(ctx context.Context, driverID *string) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByDriverID, driverID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Type,
		&i.Brand,
		&i.Model,
		&i.Year,
		&i.Plate,
		&i.Vin,
		&i.Color,
		&i.InsurancePolicy,
		&i.InsuranceExpiresAt,
		&i.InspectionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Capacity,
	)
	return i, err
}

const getVehicleByID = `-- name: GetVehicleByID :one
SELECT id, driver_id, type, brand, model, year, plate, vin, color, insurance_policy, insurance_expires_at, inspection_expires_at, created_at, updated_at, status, capacity FROM vehicles
WHERE id = $1
`

func (q *Queries) GetVehicleByID(ctx context.Context, id pgtype.UUID) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByID, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Type,
		&i.Brand,
		&i.Model,
		&i.Year,
		&i.Plate,
		&i.Vin,
		&i.Color,
		&i.InsurancePolicy,
		&i.InsuranceExpiresAt,
		&i.InspectionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Capacity,
	)
	return i, err
}

const getVehiclePhotos = `-- name: GetVehiclePhotos :many
SELECT url FROM vehicle_photos
WHERE vehicle_id = $1
ORDER BY created_at
`

func (q *Queries) GetVehiclePhotos(ctx context.Context, vehicleID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getVehiclePhotos, vehicleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var url string
		if err := rows.Scan(&url); err != nil {
			return nil, err
		}
		items = append(items, url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehicles = `-- name: ListVehicles :many
SELECT id, driver_id, type, brand, model, year, plate, vin, color, insurance_policy, insurance_expires_at, inspection_expires_at, created_at, updated_at, status, capacity FROM vehicles
WHERE 
    ($1::text IS NULL OR 
        brand ILIKE '%' || $1 || '%' OR 
        model ILIKE '%' || $1 || '%' OR 
        plate ILIKE '%' || $1 || '%')
    AND ($2::vehicle_type IS NULL OR type = $2)
    AND ($3::vehicle_status IS NULL OR status = $3)
    AND ($4::text IS NULL OR driver_id = $4)
ORDER BY
    CASE WHEN $5 = 'brand' THEN brand END,
    CASE WHEN $5 = 'model' THEN model END,
    CASE WHEN $5 = 'year' THEN year::text END,
    CASE WHEN $5 = 'created_at' THEN created_at::text END DESC,
    created_at DESC
LIMIT $6 OFFSET $7
`

type ListVehiclesParams struct {
	Column1 string        `json:"column_1"`
	Column2 VehicleType   `json:"column_2"`
	Column3 VehicleStatus `json:"column_3"`
	Column4 string        `json:"column_4"`
	Column5 interface{}   `json:"column_5"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

func (q *Queries) ListVehicles(ctx context.Context, arg ListVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehicles,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.Type,
			&i.Brand,
			&i.Model,
			&i.Year,
			&i.Plate,
			&i.Vin,
			&i.Color,
			&i.InsurancePolicy,
			&i.InsuranceExpiresAt,
			&i.InspectionExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.Capacity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unassignVehicleFromDriver = `-- name: UnassignVehicleFromDriver :exec
UPDATE vehicles
SET 
    driver_id = NULL,
    status = 'AVAILABLE',
    updated_at = NOW()
WHERE driver_id = $1
`

func (q *Queries) UnassignVehicleFromDriver(ctx context.Context, driverID *string) error {
	_, err := q.db.Exec(ctx, unassignVehicleFromDriver, driverID)
	return err
}

const updateVehicle = `-- name: UpdateVehicle :one
UPDATE vehicles
SET
    type = COALESCE($2, type),
    brand = COALESCE($3, brand),
    model = COALESCE($4, model),
    year = COALESCE($5, year),
    plate = COALESCE($6, plate),
    vin = COALESCE($7, vin),
    color = COALESCE($8, color),
    capacity = COALESCE($9, capacity),
    insurance_policy = COALESCE($10, insurance_policy),
    insurance_expires_at = COALESCE($11, insurance_expires_at),
    inspection_expires_at = COALESCE($12, inspection_expires_at),
    status = COALESCE($13, status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, driver_id, type, brand, model, year, plate, vin, color, insurance_policy, insurance_expires_at, inspection_expires_at, created_at, updated_at, status, capacity
`

type UpdateVehicleParams struct {
	ID                  pgtype.UUID   `json:"id"`
	Type                VehicleType   `json:"type"`
	Brand               string        `json:"brand"`
	Model               string        `json:"model"`
	Year                *int32        `json:"year"`
	Plate               *string       `json:"plate"`
	Vin                 *string       `json:"vin"`
	Color               *string       `json:"color"`
	Capacity            *int32        `json:"capacity"`
	InsurancePolicy     *string       `json:"insurance_policy"`
	InsuranceExpiresAt  pgtype.Date   `json:"insurance_expires_at"`
	InspectionExpiresAt pgtype.Date   `json:"inspection_expires_at"`
	Status              VehicleStatus `json:"status"`
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicle,
		arg.ID,
		arg.Type,
		arg.Brand,
		arg.Model,
		arg.Year,
		arg.Plate,
		arg.Vin,
		arg.Color,
		arg.Capacity,
		arg.InsurancePolicy,
		arg.InsuranceExpiresAt,
		arg.InspectionExpiresAt,
		arg.Status,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.Type,
		&i.Brand,
		&i.Model,
		&i.Year,
		&i.Plate,
		&i.Vin,
		&i.Color,
		&i.InsurancePolicy,
		&i.InsuranceExpiresAt,
		&i.InspectionExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.Capacity,
	)
	return i, err
}
