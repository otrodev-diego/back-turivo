// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reservations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countReservations = `-- name: CountReservations :one
SELECT COUNT(*) FROM reservations
WHERE ($1::text IS NULL OR pickup ILIKE '%' || $1 || '%' OR destination ILIKE '%' || $1 || '%' OR id ILIKE '%' || $1 || '%')
  AND ($2::reservation_status IS NULL OR status = $2)
  AND ($3::uuid IS NULL OR user_id = $3)
  AND ($4::uuid IS NULL OR org_id = $4)
`

type CountReservationsParams struct {
	Column1 string            `json:"column_1"`
	Column2 ReservationStatus `json:"column_2"`
	Column3 pgtype.UUID       `json:"column_3"`
	Column4 pgtype.UUID       `json:"column_4"`
}

func (q *Queries) CountReservations(ctx context.Context, arg CountReservationsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReservations,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, assigned_driver_id, distance_km)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, created_at, updated_at, assigned_driver_id, distance_km, arrived_on_time
`

type CreateReservationParams struct {
	ID               string             `json:"id"`
	UserID           pgtype.UUID        `json:"user_id"`
	OrgID            pgtype.UUID        `json:"org_id"`
	Pickup           string             `json:"pickup"`
	Destination      string             `json:"destination"`
	Datetime         pgtype.Timestamptz `json:"datetime"`
	Passengers       int32              `json:"passengers"`
	Status           ReservationStatus  `json:"status"`
	Amount           pgtype.Numeric     `json:"amount"`
	Notes            *string            `json:"notes"`
	AssignedDriverID *string            `json:"assigned_driver_id"`
	DistanceKm       pgtype.Numeric     `json:"distance_km"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation,
		arg.ID,
		arg.UserID,
		arg.OrgID,
		arg.Pickup,
		arg.Destination,
		arg.Datetime,
		arg.Passengers,
		arg.Status,
		arg.Amount,
		arg.Notes,
		arg.AssignedDriverID,
		arg.DistanceKm,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.Pickup,
		&i.Destination,
		&i.Datetime,
		&i.Passengers,
		&i.Status,
		&i.Amount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedDriverID,
		&i.DistanceKm,
		&i.ArrivedOnTime,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :exec
DELETE FROM reservations WHERE id = $1
`

func (q *Queries) DeleteReservation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const getReservationByID = `-- name: GetReservationByID :one
SELECT r.id, r.user_id, r.org_id, r.pickup, r.destination, r.datetime, r.passengers, r.status, r.amount, r.notes, r.created_at, r.updated_at, r.assigned_driver_id, r.distance_km, r.arrived_on_time, d.id as driver_id, d.first_name, d.last_name, d.phone, d.email, d.status as driver_status
FROM reservations r
LEFT JOIN drivers d ON r.assigned_driver_id = d.id
WHERE r.id = $1
`

type GetReservationByIDRow struct {
	ID               string             `json:"id"`
	UserID           pgtype.UUID        `json:"user_id"`
	OrgID            pgtype.UUID        `json:"org_id"`
	Pickup           string             `json:"pickup"`
	Destination      string             `json:"destination"`
	Datetime         pgtype.Timestamptz `json:"datetime"`
	Passengers       int32              `json:"passengers"`
	Status           ReservationStatus  `json:"status"`
	Amount           pgtype.Numeric     `json:"amount"`
	Notes            *string            `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	AssignedDriverID *string            `json:"assigned_driver_id"`
	DistanceKm       pgtype.Numeric     `json:"distance_km"`
	ArrivedOnTime    *bool              `json:"arrived_on_time"`
	DriverID         *string            `json:"driver_id"`
	FirstName        *string            `json:"first_name"`
	LastName         *string            `json:"last_name"`
	Phone            *string            `json:"phone"`
	Email            *string            `json:"email"`
	DriverStatus     NullDriverStatus   `json:"driver_status"`
}

func (q *Queries) GetReservationByID(ctx context.Context, id string) (GetReservationByIDRow, error) {
	row := q.db.QueryRow(ctx, getReservationByID, id)
	var i GetReservationByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.Pickup,
		&i.Destination,
		&i.Datetime,
		&i.Passengers,
		&i.Status,
		&i.Amount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedDriverID,
		&i.DistanceKm,
		&i.ArrivedOnTime,
		&i.DriverID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
		&i.DriverStatus,
	)
	return i, err
}

const getReservationsByDateRange = `-- name: GetReservationsByDateRange :many
SELECT id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, created_at, updated_at, assigned_driver_id, distance_km, arrived_on_time FROM reservations
WHERE datetime BETWEEN $1 AND $2
ORDER BY datetime ASC
`

type GetReservationsByDateRangeParams struct {
	Datetime   pgtype.Timestamptz `json:"datetime"`
	Datetime_2 pgtype.Timestamptz `json:"datetime_2"`
}

func (q *Queries) GetReservationsByDateRange(ctx context.Context, arg GetReservationsByDateRangeParams) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, getReservationsByDateRange, arg.Datetime, arg.Datetime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrgID,
			&i.Pickup,
			&i.Destination,
			&i.Datetime,
			&i.Passengers,
			&i.Status,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedDriverID,
			&i.DistanceKm,
			&i.ArrivedOnTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsByStatus = `-- name: GetReservationsByStatus :many
SELECT id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, created_at, updated_at, assigned_driver_id, distance_km, arrived_on_time FROM reservations
WHERE status = $1
ORDER BY datetime ASC
`

func (q *Queries) GetReservationsByStatus(ctx context.Context, status ReservationStatus) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, getReservationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrgID,
			&i.Pickup,
			&i.Destination,
			&i.Datetime,
			&i.Passengers,
			&i.Status,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedDriverID,
			&i.DistanceKm,
			&i.ArrivedOnTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservations = `-- name: ListReservations :many
SELECT id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, created_at, updated_at, assigned_driver_id, distance_km, arrived_on_time FROM reservations
WHERE ($1::text IS NULL OR pickup ILIKE '%' || $1 || '%' OR destination ILIKE '%' || $1 || '%' OR id ILIKE '%' || $1 || '%')
  AND ($2::reservation_status IS NULL OR status = $2)
  AND ($3::uuid IS NULL OR user_id = $3)
  AND ($4::uuid IS NULL OR org_id = $4)
ORDER BY 
  CASE WHEN $5 = 'datetime' THEN datetime END DESC,
  CASE WHEN $5 = 'created_at' THEN created_at END DESC,
  CASE WHEN $5 = 'id' THEN id END
LIMIT $6 OFFSET $7
`

type ListReservationsParams struct {
	Column1 string            `json:"column_1"`
	Column2 ReservationStatus `json:"column_2"`
	Column3 pgtype.UUID       `json:"column_3"`
	Column4 pgtype.UUID       `json:"column_4"`
	Column5 interface{}       `json:"column_5"`
	Limit   int32             `json:"limit"`
	Offset  int32             `json:"offset"`
}

func (q *Queries) ListReservations(ctx context.Context, arg ListReservationsParams) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservations,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrgID,
			&i.Pickup,
			&i.Destination,
			&i.Datetime,
			&i.Passengers,
			&i.Status,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedDriverID,
			&i.DistanceKm,
			&i.ArrivedOnTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservation = `-- name: UpdateReservation :one
UPDATE reservations
SET pickup = COALESCE($2, pickup),
    destination = COALESCE($3, destination),
    datetime = COALESCE($4, datetime),
    passengers = COALESCE($5, passengers),
    status = COALESCE($6, status),
    amount = COALESCE($7, amount),
    notes = COALESCE($8, notes),
    assigned_driver_id = COALESCE($9, assigned_driver_id),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, created_at, updated_at, assigned_driver_id, distance_km, arrived_on_time
`

type UpdateReservationParams struct {
	ID               string             `json:"id"`
	Pickup           string             `json:"pickup"`
	Destination      string             `json:"destination"`
	Datetime         pgtype.Timestamptz `json:"datetime"`
	Passengers       int32              `json:"passengers"`
	Status           ReservationStatus  `json:"status"`
	Amount           pgtype.Numeric     `json:"amount"`
	Notes            *string            `json:"notes"`
	AssignedDriverID *string            `json:"assigned_driver_id"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservation,
		arg.ID,
		arg.Pickup,
		arg.Destination,
		arg.Datetime,
		arg.Passengers,
		arg.Status,
		arg.Amount,
		arg.Notes,
		arg.AssignedDriverID,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.Pickup,
		&i.Destination,
		&i.Datetime,
		&i.Passengers,
		&i.Status,
		&i.Amount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedDriverID,
		&i.DistanceKm,
		&i.ArrivedOnTime,
	)
	return i, err
}

const updateReservationStatus = `-- name: UpdateReservationStatus :one
UPDATE reservations
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, org_id, pickup, destination, datetime, passengers, status, amount, notes, created_at, updated_at, assigned_driver_id, distance_km, arrived_on_time
`

type UpdateReservationStatusParams struct {
	ID     string            `json:"id"`
	Status ReservationStatus `json:"status"`
}

func (q *Queries) UpdateReservationStatus(ctx context.Context, arg UpdateReservationStatusParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservationStatus, arg.ID, arg.Status)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.Pickup,
		&i.Destination,
		&i.Datetime,
		&i.Passengers,
		&i.Status,
		&i.Amount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedDriverID,
		&i.DistanceKm,
		&i.ArrivedOnTime,
	)
	return i, err
}
