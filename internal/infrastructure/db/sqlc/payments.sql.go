// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(*) FROM payments p
WHERE ($1::text IS NULL OR p.reservation_id ILIKE '%' || $1 || '%' OR p.transaction_ref ILIKE '%' || $1 || '%')
  AND ($2::payment_status IS NULL OR p.status = $2)
  AND ($3::payment_gateway IS NULL OR p.gateway = $3)
`

type CountPaymentsParams struct {
	Column1 string         `json:"column_1"`
	Column2 PaymentStatus  `json:"column_2"`
	Column3 PaymentGateway `json:"column_3"`
}

func (q *Queries) CountPayments(ctx context.Context, arg CountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (id, reservation_id, gateway, amount, currency, status, transaction_ref, payload)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at
`

type CreatePaymentParams struct {
	ID             pgtype.UUID    `json:"id"`
	ReservationID  string         `json:"reservation_id"`
	Gateway        PaymentGateway `json:"gateway"`
	Amount         pgtype.Numeric `json:"amount"`
	Currency       string         `json:"currency"`
	Status         PaymentStatus  `json:"status"`
	TransactionRef *string        `json:"transaction_ref"`
	Payload        []byte         `json:"payload"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.ID,
		arg.ReservationID,
		arg.Gateway,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.TransactionRef,
		arg.Payload,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.Gateway,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TransactionRef,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at FROM payments WHERE id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.Gateway,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TransactionRef,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentByTransactionRef = `-- name: GetPaymentByTransactionRef :one
SELECT id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at FROM payments WHERE transaction_ref = $1
`

func (q *Queries) GetPaymentByTransactionRef(ctx context.Context, transactionRef *string) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByTransactionRef, transactionRef)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.Gateway,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TransactionRef,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentsByReservationID = `-- name: GetPaymentsByReservationID :many
SELECT id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at FROM payments WHERE reservation_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetPaymentsByReservationID(ctx context.Context, reservationID string) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByReservationID, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.Gateway,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.TransactionRef,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByStatus = `-- name: GetPaymentsByStatus :many
SELECT id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at FROM payments
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPaymentsByStatus(ctx context.Context, status PaymentStatus) ([]Payment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.Gateway,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.TransactionRef,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayments = `-- name: ListPayments :many
SELECT p.id, p.reservation_id, p.gateway, p.amount, p.currency, p.status, p.transaction_ref, p.payload, p.created_at, r.pickup, r.destination 
FROM payments p
LEFT JOIN reservations r ON p.reservation_id = r.id
WHERE ($1::text IS NULL OR p.reservation_id ILIKE '%' || $1 || '%' OR p.transaction_ref ILIKE '%' || $1 || '%')
  AND ($2::payment_status IS NULL OR p.status = $2)
  AND ($3::payment_gateway IS NULL OR p.gateway = $3)
ORDER BY 
  CASE WHEN $4 = 'created_at' THEN p.created_at END DESC,
  CASE WHEN $4 = 'amount' THEN p.amount END DESC
LIMIT $5 OFFSET $6
`

type ListPaymentsParams struct {
	Column1 string         `json:"column_1"`
	Column2 PaymentStatus  `json:"column_2"`
	Column3 PaymentGateway `json:"column_3"`
	Column4 interface{}    `json:"column_4"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type ListPaymentsRow struct {
	ID             pgtype.UUID        `json:"id"`
	ReservationID  string             `json:"reservation_id"`
	Gateway        PaymentGateway     `json:"gateway"`
	Amount         pgtype.Numeric     `json:"amount"`
	Currency       string             `json:"currency"`
	Status         PaymentStatus      `json:"status"`
	TransactionRef *string            `json:"transaction_ref"`
	Payload        []byte             `json:"payload"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Pickup         *string            `json:"pickup"`
	Destination    *string            `json:"destination"`
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]ListPaymentsRow, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsRow{}
	for rows.Next() {
		var i ListPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.Gateway,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.TransactionRef,
			&i.Payload,
			&i.CreatedAt,
			&i.Pickup,
			&i.Destination,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET status = COALESCE($2, status),
    transaction_ref = COALESCE($3, transaction_ref),
    payload = COALESCE($4, payload)
WHERE id = $1
RETURNING id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at
`

type UpdatePaymentParams struct {
	ID             pgtype.UUID   `json:"id"`
	Status         PaymentStatus `json:"status"`
	TransactionRef *string       `json:"transaction_ref"`
	Payload        []byte        `json:"payload"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.ID,
		arg.Status,
		arg.TransactionRef,
		arg.Payload,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.Gateway,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TransactionRef,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET status = $2
WHERE id = $1
RETURNING id, reservation_id, gateway, amount, currency, status, transaction_ref, payload, created_at
`

type UpdatePaymentStatusParams struct {
	ID     pgtype.UUID   `json:"id"`
	Status PaymentStatus `json:"status"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus, arg.ID, arg.Status)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.Gateway,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.TransactionRef,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}
