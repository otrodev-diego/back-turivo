// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: driver_feedback.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDriverFeedback = `-- name: CreateDriverFeedback :one
INSERT INTO driver_feedback (driver_id, reservation_id, rating, comment)
VALUES ($1, $2, $3, $4)
RETURNING id, driver_id, reservation_id, rating, comment, created_at, updated_at
`

type CreateDriverFeedbackParams struct {
	DriverID      string         `json:"driver_id"`
	ReservationID string         `json:"reservation_id"`
	Rating        pgtype.Numeric `json:"rating"`
	Comment       *string        `json:"comment"`
}

func (q *Queries) CreateDriverFeedback(ctx context.Context, arg CreateDriverFeedbackParams) (DriverFeedback, error) {
	row := q.db.QueryRow(ctx, createDriverFeedback,
		arg.DriverID,
		arg.ReservationID,
		arg.Rating,
		arg.Comment,
	)
	var i DriverFeedback
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.ReservationID,
		&i.Rating,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriverFeedback = `-- name: GetDriverFeedback :many
SELECT id, driver_id, reservation_id, rating, comment, created_at, updated_at FROM driver_feedback 
WHERE driver_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetDriverFeedback(ctx context.Context, driverID string) ([]DriverFeedback, error) {
	rows, err := q.db.Query(ctx, getDriverFeedback, driverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DriverFeedback{}
	for rows.Next() {
		var i DriverFeedback
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.ReservationID,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriverRealKPIs = `-- name: GetDriverRealKPIs :one
SELECT 
    -- Total trips completed
    (SELECT COUNT(*) FROM reservations r
     WHERE r.assigned_driver_id = $1 AND r.status = 'COMPLETADA') as total_trips,
    
    -- Total kilometers
    (SELECT COALESCE(SUM(r.distance_km), 0) FROM reservations r
     WHERE r.assigned_driver_id = $1 AND r.status = 'COMPLETADA') as total_km,
    
    -- On-time rate (percentage)
    (SELECT CASE 
        WHEN COUNT(*) = 0 THEN 0
        ELSE ROUND(
            (COUNT(CASE WHEN r.arrived_on_time = true THEN 1 END) * 100.0 / COUNT(*))::DECIMAL, 1
        )
     END FROM reservations r
     WHERE r.assigned_driver_id = $1 AND r.status = 'COMPLETADA') as on_time_rate,
    
    -- Cancel rate (percentage)
    (SELECT CASE 
        WHEN COUNT(*) = 0 THEN 0
        ELSE ROUND(
            (COUNT(CASE WHEN r.status = 'CANCELADA' THEN 1 END) * 100.0 / COUNT(*))::DECIMAL, 1
        )
     END FROM reservations r
     WHERE r.assigned_driver_id = $1) as cancel_rate,
    
    -- Average rating
    (SELECT COALESCE(ROUND(AVG(df.rating)::DECIMAL, 1), 0) FROM driver_feedback df
     WHERE df.driver_id = $1) as average_rating
`

type GetDriverRealKPIsRow struct {
	TotalTrips    int64       `json:"total_trips"`
	TotalKm       interface{} `json:"total_km"`
	OnTimeRate    interface{} `json:"on_time_rate"`
	CancelRate    interface{} `json:"cancel_rate"`
	AverageRating interface{} `json:"average_rating"`
}

func (q *Queries) GetDriverRealKPIs(ctx context.Context, assignedDriverID *string) (GetDriverRealKPIsRow, error) {
	row := q.db.QueryRow(ctx, getDriverRealKPIs, assignedDriverID)
	var i GetDriverRealKPIsRow
	err := row.Scan(
		&i.TotalTrips,
		&i.TotalKm,
		&i.OnTimeRate,
		&i.CancelRate,
		&i.AverageRating,
	)
	return i, err
}
